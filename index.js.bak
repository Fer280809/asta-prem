process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '1'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– NEYROX BOT MAX - SISTEMA PRINCIPAL v3.0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import './config.js'
import { 
  makeWASocket, 
  DisconnectReason, 
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  makeCacheableSignalKeyStore 
} from '@whiskeysockets/baileys'
import { Boom } from '@hapi/boom'
import pino from 'pino'
import cfonts from 'cfonts'
import chalk from 'chalk'
import { handler } from './lib/handler.js'
import { loadPlugins } from './lib/loader.js'
import { createWelcomeImage, createGoodbyeImage } from './lib/canvas.js'
import { downloadProfilePicture } from './lib/utils.js'
import { getGroup, save } from './lib/database.js'
import fs from 'fs'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ BANNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.clear()

cfonts.say('NEYROX', {
  font: 'block',
  align: 'center',
  gradient: ['#00D9FF', '#FF006E'],
  space: false
})

cfonts.say('BOT MAX', {
  font: 'tiny',
  align: 'center',
  colors: ['#00FF88']
})

console.log(chalk.cyan('\n' + 'â•'.repeat(50)))
console.log(chalk.white('  VersiÃ³n:'), chalk.yellow('3.0.0'))
console.log(chalk.white('  Baileys:'), chalk.yellow('Latest (GitHub)'))
console.log(chalk.white('  Canvas:'), chalk.yellow('@napi-rs/canvas'))
console.log(chalk.white('  Node:'), chalk.yellow(process.version))
console.log(chalk.cyan('â•'.repeat(50) + '\n'))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ DIRECTORIOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const dirs = ['sessions', 'tmp', 'commands', 'events', 'assets']
for (const dir of dirs) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ BAILEYS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const logger = pino({ level: 'silent' })
const { state, saveCreds } = await useMultiFileAuthState(global.config.sessionDir)
const { version } = await fetchLatestBaileysVersion()

console.log(chalk.blue(`ğŸ“¦ Baileys v${version.join('.')}`))

const sock = makeWASocket({
  version,
  logger,
  printQRInTerminal: true,
  auth: {
    creds: state.creds,
    keys: makeCacheableSignalKeyStore(state.keys, logger)
  },
  browser: ['Neyrox-Bot-Max', 'Chrome', '120.0.0'],
  generateHighQualityLinkPreview: true,
  syncFullHistory: false,
  markOnlineOnConnect: true
})

sock.ev.on('creds.update', saveCreds)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¡ CONEXIÃ“N
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sock.ev.on('connection.update', async (update) => {
  const { connection, lastDisconnect, qr } = update

  if (qr) {
    console.log(chalk.yellow('\nğŸ“± Escanea el QR code arriba\n'))
  }

  if (connection === 'close') {
    const shouldReconnect = (lastDisconnect?.error instanceof Boom) 
      ? lastDisconnect.error.output.statusCode !== DisconnectReason.loggedOut
      : true

    console.log(chalk.red('\nâŒ Desconectado'))

    if (shouldReconnect) {
      console.log(chalk.yellow('ğŸ”„ Reconectando...'))
      setTimeout(() => process.exit(1), 3000)
    }
  }

  if (connection === 'open') {
    console.log(chalk.greenBright('\n' + 'â•'.repeat(50)))
    console.log(chalk.greenBright('  âœ… BOT CONECTADO'))
    console.log(chalk.greenBright('â•'.repeat(50) + '\n'))

    const user = sock.user
    console.log(chalk.cyan(`ğŸ‘¤ ${user?.name || 'Unknown'}`))
    console.log(chalk.cyan(`ğŸ“± ${user?.id?.split(':')[0] || 'Unknown'}\n`))

    await loadPlugins(sock)

    for (const owner of global.config.owners) {
      try {
        await sock.sendMessage(owner + '@s.whatsapp.net', {
          text: `âœ… *${global.config.botName}* Max conectado!\n\nğŸ“… ${new Date().toLocaleString()}`
        })
      } catch {}
    }
  }
})

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¬ MENSAJES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sock.ev.on('messages.upsert', async (m) => {
  const msg = m.messages[0]
  if (!msg.message || msg.key.remoteJid === 'status@broadcast') return

  await handler(sock, msg, sock, false, null)
})

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ‘¥ GRUPOS - BIENVENIDA CON CANVAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sock.ev.on('group-participants.update', async (update) => {
  const { id, participants, action } = update

  try {
    const group = getGroup(id)
    const groupMetadata = await sock.groupMetadata(id)
    const groupName = groupMetadata.subject

    // BIENVENIDA
    if (action === 'add' && group.welcome !== false) {
      for (const user of participants) {
        try {
          let avatarBuffer = null
          try {
            avatarBuffer = await downloadProfilePicture(sock, user)
          } catch {}

          const userName = await sock.getName(user) || 'Usuario'
          const userNumber = user.split('@')[0]
          const memberCount = groupMetadata.participants.length

          const imageBuffer = await createWelcomeImage(
            userName, userNumber, groupName, avatarBuffer, memberCount
          )

          await sock.sendMessage(id, {
            image: imageBuffer,
            caption: `ğŸ‘‹ *Bienvenido* @${userNumber}\n\nğŸ“ *${groupName}*\nğŸ‘¥ Miembro #${memberCount}`,
            mentions: [user]
          })

        } catch (err) {
          await sock.sendMessage(id, {
            text: `ğŸ‘‹ *Bienvenido* @${user.split('@')[0]}\n\nğŸ“ *${groupName}*`,
            mentions: [user]
          })
        }
      }
    }

    // DESPEDIDA
    if (action === 'remove' && group.welcome !== false) {
      for (const user of participants) {
        try {
          const userName = await sock.getName(user) || 'Usuario'
          const userNumber = user.split('@')[0]
          const remainingCount = groupMetadata.participants.length - 1

          const imageBuffer = await createGoodbyeImage(
            userName, userNumber, groupName, remainingCount
          )

          await sock.sendMessage(id, {
            image: imageBuffer,
            caption: `ğŸ‘‹ *Hasta luego* @${userNumber}`,
            mentions: [user]
          })

        } catch {
          await sock.sendMessage(id, {
            text: `ğŸ‘‹ *AdiÃ³s* @${user.split('@')[0]}`,
            mentions: [user]
          })
        }
      }
    }

    // PROMOTE/DEMOTE
    if (action === 'promote' || action === 'demote') {
      for (const user of participants) {
        const num = user.split('@')[0]

        if (action === 'promote') {
          await sock.sendMessage(id, {
            text: `ğŸ‘‘ *Nuevo Admin* @${num}`,
            mentions: [user]
          })
        } else {
          await sock.sendMessage(id, {
            text: `âš ï¸ *Admin removido* @${num}`,
            mentions: [user]
          })
        }
      }
    }

  } catch (error) {
    console.error('Error group event:', error)
  }
})

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ CAMBIOS EN GRUPO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sock.ev.on('groups.update', async (updates) => {
  try {
    for (const update of updates) {
      const { id, subject, desc, restrict, announce } = update

      if (!id) continue

      let message = `ğŸ“¢ *ActualizaciÃ³n del Grupo*\n\n`

      if (subject) message += `ğŸ“ *Nuevo nombre:* ${subject}\n`
      if (desc) message += `ğŸ“„ *Nueva descripciÃ³n*\n`
      if (restrict !== undefined) message += `ğŸ”’ *EdiciÃ³n:* ${restrict ? 'Solo admins' : 'Todos'}\n`
      if (announce !== undefined) message += `ğŸ“¢ *Mensajes:* ${announce ? 'Solo admins' : 'Todos'}\n`

      await sock.sendMessage(id, { text: message.trim() })
    }
  } catch (error) {
    console.error('Error groups.update:', error)
  }
})

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›‘ ERRORES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

process.on('uncaughtException', console.error)
process.on('unhandledRejection', console.error)

global.sock = sock

console.log(chalk.cyan('\nâ³ Conectando...\n'))
